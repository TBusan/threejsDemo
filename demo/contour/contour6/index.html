<!DOCTYPE html>
<html lang="en">

<head>
    <title>three.js webgl - animation - keyframes</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            background-color: #bfe3dd;
            color: #000;
        }

        a {
            color: #2983ff;
        }

        #container {
            width: 1000px;
            height: 1000px;
        }
    </style>
</head>

<body>

    <div id="container"></div>

    <div id="info">
        <a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> webgl - animation - keyframes<br />
        Model: <a href="https://artstation.com/artwork/1AGwX" target="_blank" rel="noopener">Littlest Tokyo</a> by
        <a href="https://artstation.com/glenatron" target="_blank" rel="noopener">Glen Fox</a>, CC Attribution.
    </div>

    <script type="importmap">
			
				{
                    "imports": {
                        "three": "../../../build/three.module.js",
                        "three/addons/": "../../../examples/jsm/"
                    }
                }
			
		</script>

    <script type="module">

        import * as THREE from 'three';

        import Stats from 'three/addons/libs/stats.module.js';

        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';

        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';

        let camera, scene, renderer, controls;
        const container = document.getElementById('container');

        class ContourPlot {
            constructor(data) {
                this.data = data[0];
                this.group = new THREE.Group();
                this.smoothing = this.data.line?.smoothing || 0;
                this.showFill = this.data.contours?.coloring !== 'lines';
                this.width = Math.abs(this.data.x[this.data.x.length - 1] - this.data.x[0]);
                this.height = Math.abs(this.data.y[this.data.y.length - 1] - this.data.y[0]);
                this.createPlot();
            }

            createPlot() {
                if (this.showFill) {
                    this.createGradientLayer();
                }
                this.createContourLines();
                this.createGrid();
                this.createAxes();
                
                // 调整整个图的位置
                this.group.position.set(-this.width/2, -this.height/2, 0);
            }

            createContourLines() {
                const contours = this.generateContours();
                
                // 使用渐变色方案，从蓝到绿到红
                contours.forEach((points, index) => {
                    const geometry = new THREE.BufferGeometry().setFromPoints(points);
                    // 根据等值线的值来确定颜色
                    const value = this.levels[index];
                    const normalizedValue = (value - this.minValue) / (this.maxValue - this.minValue);
                    
                    let color;
                    if (normalizedValue < 0.5) {
                        color = new THREE.Color().setHSL(0.6, 1, 0.5); // 蓝色
                    } else if (normalizedValue < 0.75) {
                        color = new THREE.Color().setHSL(0.3, 1, 0.5); // 绿色
                    } else {
                        color = new THREE.Color().setHSL(0.0, 1, 0.5); // 红色
                    }

                    const material = new THREE.LineBasicMaterial({
                        color: color,
                        linewidth: 1,
                        opacity: 1,
                        transparent: false
                    });
                    const line = new THREE.Line(geometry, material);
                    this.group.add(line);
                });
            }

            generateContours() {
                const values = this.data.v;
                const width = values[0].length;
                const height = values.length;
                
                // 计算数据范围
                this.minValue = Infinity;
                this.maxValue = -Infinity;
                for (let i = 0; i < height; i++) {
                    for (let j = 0; j < width; j++) {
                        const val = values[i][j];
                        if (isFinite(val)) {
                            this.minValue = Math.min(this.minValue, val);
                            this.maxValue = Math.max(this.maxValue, val);
                        }
                    }
                }

                // 生成更密集的等值线级别
                this.levels = [];
                const levelCount = 25; // 增加等值线数量
                const step = (this.maxValue - this.minValue) / (levelCount - 1);
                for (let i = 0; i < levelCount; i++) {
                    this.levels.push(this.minValue + step * i);
                }

                const contours = [];
                this.levels.forEach(level => {
                    const levelContours = this.traceContourLevel(level);
                    if (levelContours.length > 0) {
                        contours.push(...levelContours);
                    }
                });

                return contours;
            }

            traceContourLevel(level) {
                const contours = [];
                const visited = new Set();
                const width = this.data.v[0].length;
                const height = this.data.v.length;

                // 扫描所有单元格寻找起始点
                for (let y = 0; y < height - 1; y++) {
                    for (let x = 0; x < width - 1; x++) {
                        if (visited.has(`${x},${y}`)) continue;

                        const contour = this.traceContour(x, y, level, visited);
                        if (contour && contour.length > 2) {
                            contours.push(contour);
                        }
                    }
                }

                return contours;
            }

            traceContour(startX, startY, level, visited) {
                const points = [];
                let x = startX, y = startY;
                const eps = 1e-6;

                while (true) {
                    const key = `${x},${y}`;
                    if (visited.has(key)) break;
                    visited.add(key);

                    const cellPoints = this.getCellContourPoints(x, y, level);
                    if (!cellPoints || cellPoints.length !== 2) break;

                    if (points.length === 0) {
                        points.push(...cellPoints);
                    } else {
                        const lastPoint = points[points.length - 1];
                        // 使用更精确的点连接策略
                        if (lastPoint.distanceTo(cellPoints[0]) < eps) {
                            points.push(cellPoints[1]);
                        } else if (lastPoint.distanceTo(cellPoints[1]) < eps) {
                            points.push(cellPoints[0]);
                        } else {
                            // 如果没有直接连接的点，尝试插值连接
                            const midPoint = new THREE.Vector3().addVectors(lastPoint, cellPoints[0]).multiplyScalar(0.5);
                            points.push(midPoint, cellPoints[0], cellPoints[1]);
                        }
                    }

                    const nextCell = this.findNextCell(x, y, points[points.length - 1]);
                    if (!nextCell) break;
                    x = nextCell.x;
                    y = nextCell.y;
                }

                // 对生成的点进行平滑处理
                return this.smoothPoints(points);
            }

            findNextCell(x, y, endPoint) {
                const eps = 0.0001;
                const cells = [
                    {x: x+1, y: y},
                    {x: x, y: y+1},
                    {x: x-1, y: y},
                    {x: x, y: y-1}
                ];

                for (const cell of cells) {
                    if (!this.isValidCell(cell.x, cell.y)) continue;

                    const x0 = this.data.x[cell.x];
                    const x1 = this.data.x[cell.x + 1];
                    const y0 = this.data.y[cell.y];
                    const y1 = this.data.y[cell.y + 1];

                    // 检查端点是否在单元格边界上
                    if (Math.abs(endPoint.x - x0) < eps && endPoint.y >= y0 && endPoint.y <= y1) {
                        return cell;
                    }
                    if (Math.abs(endPoint.x - x1) < eps && endPoint.y >= y0 && endPoint.y <= y1) {
                        return cell;
                    }
                    if (Math.abs(endPoint.y - y0) < eps && endPoint.x >= x0 && endPoint.x <= x1) {
                        return cell;
                    }
                    if (Math.abs(endPoint.y - y1) < eps && endPoint.x >= x0 && endPoint.x <= x1) {
                        return cell;
                    }
                }

                return null;
            }

            getCellContourPoints(x, y, level) {
                const v00 = this.data.v[y][x];
                const v10 = this.data.v[y][x + 1];
                const v11 = this.data.v[y + 1][x + 1];
                const v01 = this.data.v[y + 1][x];

                if (!isFinite(v00) || !isFinite(v10) || !isFinite(v11) || !isFinite(v01)) {
                    return null;
                }

                const x0 = this.data.x[x];
                const x1 = this.data.x[x + 1];
                const y0 = this.data.y[y];
                const y1 = this.data.y[y + 1];

                let caseIndex = 0;
                if (v00 > level) caseIndex |= 1;
                if (v10 > level) caseIndex |= 2;
                if (v11 > level) caseIndex |= 4;
                if (v01 > level) caseIndex |= 8;

                const points = [];
                const interpolate = (v1, v2, p1, p2) => {
                    const t = (level - v1) / (v2 - v1);
                    return new THREE.Vector3(
                        p1.x + t * (p2.x - p1.x),
                        p1.y + t * (p2.y - p1.y),
                        0
                    );
                };

                // 完整的 Marching Squares 查找表
                switch (caseIndex) {
                    case 0: case 15:
                        // 无等值线
                        break;
                    case 1: case 14:
                        points.push(
                            interpolate(v00, v10, new THREE.Vector3(x0, y0, 0), new THREE.Vector3(x1, y0, 0)),
                            interpolate(v00, v01, new THREE.Vector3(x0, y0, 0), new THREE.Vector3(x0, y1, 0))
                        );
                        break;
                    case 2: case 13:
                        points.push(
                            interpolate(v00, v10, new THREE.Vector3(x0, y0, 0), new THREE.Vector3(x1, y0, 0)),
                            interpolate(v10, v11, new THREE.Vector3(x1, y0, 0), new THREE.Vector3(x1, y1, 0))
                        );
                        break;
                    case 3: case 12:
                        points.push(
                            interpolate(v00, v01, new THREE.Vector3(x0, y0, 0), new THREE.Vector3(x0, y1, 0)),
                            interpolate(v10, v11, new THREE.Vector3(x1, y0, 0), new THREE.Vector3(x1, y1, 0))
                        );
                        break;
                    case 4: case 11:
                        points.push(
                            interpolate(v10, v11, new THREE.Vector3(x1, y0, 0), new THREE.Vector3(x1, y1, 0)),
                            interpolate(v01, v11, new THREE.Vector3(x0, y1, 0), new THREE.Vector3(x1, y1, 0))
                        );
                        break;
                    case 5:
                        // 鞍点情况，需要检查中心点
                        const vCenter = (v00 + v10 + v11 + v01) / 4;
                        if (vCenter > level) {
                            points.push(
                                interpolate(v00, v10, new THREE.Vector3(x0, y0, 0), new THREE.Vector3(x1, y0, 0)),
                                interpolate(v01, v11, new THREE.Vector3(x0, y1, 0), new THREE.Vector3(x1, y1, 0))
                            );
                        } else {
                            points.push(
                                interpolate(v00, v01, new THREE.Vector3(x0, y0, 0), new THREE.Vector3(x0, y1, 0)),
                                interpolate(v10, v11, new THREE.Vector3(x1, y0, 0), new THREE.Vector3(x1, y1, 0))
                            );
                        }
                        break;
                    case 6: case 9:
                        points.push(
                            interpolate(v00, v10, new THREE.Vector3(x0, y0, 0), new THREE.Vector3(x1, y0, 0)),
                            interpolate(v01, v11, new THREE.Vector3(x0, y1, 0), new THREE.Vector3(x1, y1, 0))
                        );
                        break;
                    case 7: case 8:
                        points.push(
                            interpolate(v01, v11, new THREE.Vector3(x0, y1, 0), new THREE.Vector3(x1, y1, 0)),
                            interpolate(v00, v01, new THREE.Vector3(x0, y0, 0), new THREE.Vector3(x0, y1, 0))
                        );
                        break;
                    case 10:
                        // 另一个鞍点情况
                        const vCenter2 = (v00 + v10 + v11 + v01) / 4;
                        if (vCenter2 > level) {
                            points.push(
                                interpolate(v00, v01, new THREE.Vector3(x0, y0, 0), new THREE.Vector3(x0, y1, 0)),
                                interpolate(v10, v11, new THREE.Vector3(x1, y0, 0), new THREE.Vector3(x1, y1, 0))
                            );
                        } else {
                            points.push(
                                interpolate(v00, v10, new THREE.Vector3(x0, y0, 0), new THREE.Vector3(x1, y0, 0)),
                                interpolate(v01, v11, new THREE.Vector3(x0, y1, 0), new THREE.Vector3(x1, y1, 0))
                            );
                        }
                        break;
                }

                return points;
            }

            createAxes() {
                const axesGroup = new THREE.Group();
                
                // X轴
                this.createAxis(
                    axesGroup,
                    this.data.x,
                    'x',
                    new THREE.Vector3(1, 0, 0),
                    this.width
                );
                
                // Y轴
                this.createAxis(
                    axesGroup,
                    this.data.y,
                    'y',
                    new THREE.Vector3(0, 1, 0),
                    this.height
                );

                this.group.add(axesGroup);
            }

            createAxis(group, values, axisType, direction, length) {
                // 创建轴线
                const axisGeometry = new THREE.BufferGeometry().setFromPoints([
                    new THREE.Vector3(0, 0, 0),
                    direction.multiplyScalar(length)
                ]);
                const axisMaterial = new THREE.LineBasicMaterial({ color: 0x000000 });
                const axis = new THREE.Line(axisGeometry, axisMaterial);
                group.add(axis);

                // 创建刻度标签
                values.forEach(value => {
                    const position = axisType === 'x' 
                        ? new THREE.Vector3(value, 0, 0)
                        : new THREE.Vector3(0, value, 0);
                    
                    // 刻度线
                    const tickGeometry = new THREE.BufferGeometry().setFromPoints([
                        position,
                        position.clone().add(new THREE.Vector3(
                            axisType === 'y' ? -0.5 : 0,
                            axisType === 'x' ? -0.5 : 0,
                            0
                        ))
                    ]);
                    const tick = new THREE.Line(tickGeometry, axisMaterial);
                    group.add(tick);

                    // 标签
                    const label = this.createAxisLabel(value.toFixed(1), position, axisType);
                    group.add(label);
                });
            }

            createGrid() {
                const gridHelper = new THREE.GridHelper(
                    Math.max(this.width, this.height),
                    10,
                    0xcccccc,
                    0xcccccc
                );
                gridHelper.rotation.x = Math.PI / 2;
                gridHelper.position.set(
                    (this.data.x[0] + this.data.x[this.data.x.length - 1]) / 2,
                    (this.data.y[0] + this.data.y[this.data.y.length - 1]) / 2,
                    -0.1
                );
                this.group.add(gridHelper);
            }

            createAxisLabel(text, position, axisType) {
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 64;
                canvas.height = 32;

                context.fillStyle = 'black';
                context.font = '16px Arial';
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                context.fillText(text, canvas.width/2, canvas.height/2);

                const texture = new THREE.CanvasTexture(canvas);
                const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
                const sprite = new THREE.Sprite(spriteMaterial);

                const offset = 1;
                if (axisType === 'x') {
                    sprite.position.set(position.x, position.y - offset, 0);
                } else {
                    sprite.position.set(position.x - offset, position.y, 0);
                }

                sprite.scale.set(2, 1, 1);
                return sprite;
            }

            createValueTexture() {
                const width = this.data.v[0].length;
                const height = this.data.v.length;
                const data = new Float32Array(width * height);
                
                for (let i = 0; i < height; i++) {
                    for (let j = 0; j < width; j++) {
                        data[i * width + j] = this.data.v[i][j];
                    }
                }
                
                return data;
            }

            isValidCell(x, y) {
                return x >= 0 && x < this.data.v[0].length - 1 && 
                       y >= 0 && y < this.data.v.length - 1;
            }

            smoothPoints(points) {
                if (points.length < 3) return points;
                
                const smoothed = [];
                const tension = 0.25; // 平滑程度
                
                smoothed.push(points[0]);
                
                for (let i = 1; i < points.length - 1; i++) {
                    const prev = points[i - 1];
                    const curr = points[i];
                    const next = points[i + 1];
                    
                    const x = curr.x + tension * (next.x - prev.x) / 4;
                    const y = curr.y + tension * (next.y - prev.y) / 4;
                    
                    smoothed.push(new THREE.Vector3(x, y, 0));
                }
                
                smoothed.push(points[points.length - 1]);
                return smoothed;
            }
        }

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xffffff);

            // 调整相机位置和视角
            camera = new THREE.OrthographicCamera(
                -10, 10,
                10, -10,
                0.1, 1000
            );
            camera.position.set(0, 0, 50);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ 
                antialias: true,
                preserveDrawingBuffer: true
            });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(container.clientWidth, container.clientHeight);
            container.appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableRotate = false; // 禁用旋转
            controls.enableZoom = true;
            controls.enablePan = true;

            const testData = [{
                v: [[2, 4, 7, 12, 13, 14, 15, 16],
                    [3, 1, 6, 11, 12, 13, 16, 17],
                    [4, 2, 7, 7, 11, 14, 17, 18],
                    [5, 3, 8, 8, 13, 15, 18, 19],
                    [7, 4, 10, 9, 16, 18, 20, 19],
                    [9, 10, 5, 27, 23, 21, 21, 21],
                    [11, 14, 17, 26, 25, 24, 23, 22]],
                x: [0, 1, 2, 3, 4, 5, 6, 7],
                y: [0, 1, 2, 3, 4, 5, 6],
                type: 'contour',
                line: { smoothing: 0 },
                contours: { coloring: 'lines' }
            }];

            const contourPlot = new ContourPlot(testData);
            scene.add(contourPlot.group);

            window.addEventListener('resize', onWindowResize);
        }

        function onWindowResize() {
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        init();
        animate();

    </script>

</body>

</html>