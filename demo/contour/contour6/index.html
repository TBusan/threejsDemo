<!DOCTYPE html>
<html lang="en">

<head>
    <title>three.js webgl - animation - keyframes</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            background-color: #bfe3dd;
            color: #000;
        }

        a {
            color: #2983ff;
        }

        #container {
            width: 1000px;
            height: 1000px;
        }
    </style>
</head>

<body>

    <div id="container"></div>

    <div id="info">
        <a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> webgl - animation - keyframes<br />
        Model: <a href="https://artstation.com/artwork/1AGwX" target="_blank" rel="noopener">Littlest Tokyo</a> by
        <a href="https://artstation.com/glenatron" target="_blank" rel="noopener">Glen Fox</a>, CC Attribution.
    </div>

    <script type="importmap">
			
				{
                    "imports": {
                        "three": "../../../build/three.module.js",
                        "three/addons/": "../../../examples/jsm/"
                    }
                }
			
		</script>

    <script type="module">

        import * as THREE from 'three';

        import Stats from 'three/addons/libs/stats.module.js';

        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';

        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';

        import * as d3 from 'https://cdn.jsdelivr.net/npm/d3@7/+esm';

        let camera, scene, renderer, controls;
        const container = document.getElementById('container');

        class ContourPlot {
            constructor(data) {
                this.data = data[0];
                this.group = new THREE.Group();
                this.createPlot();
            }

            createPlot() {
                this.createContourLines();
                this.createGrid();
                this.createAxes();
            }

            createContourLines() {
                // 使用 d3 的 contour 生成器
                const values = this.data.v;
                const width = values[0].length;
                const height = values.length;
                const flatValues = values.flat();

                // 创建 d3 contour 生成器
                const contours = d3.contours()
                    .size([width, height])
                    .thresholds(15) // 设置等值线数量
                    (flatValues);

                // 创建坐标映射函数
                const xScale = d3.scaleLinear()
                    .domain([0, width - 1])
                    .range([this.data.x[0], this.data.x[this.data.x.length - 1]]);

                const yScale = d3.scaleLinear()
                    .domain([0, height - 1])
                    .range([this.data.y[0], this.data.y[this.data.y.length - 1]]);

                // 转换每个等值线
                contours.forEach((contour, index) => {
                    const paths = contour.coordinates;
                    const value = contour.value;
                    
                    // 为每个路径创建一个 THREE.Line
                    paths.forEach(path => {
                        path.forEach(ring => {
                            const points = ring.map(point => {
                                return new THREE.Vector3(
                                    xScale(point[0]),
                                    yScale(point[1]),
                                    0
                                );
                            });
                            
                            // 闭合路径
                            if (points.length > 0) {
                                points.push(points[0].clone());
                            }

                            const geometry = new THREE.BufferGeometry().setFromPoints(points);
                            
                            // 根据值设置颜色
                            const normalizedValue = (value - d3.min(flatValues)) / 
                                                 (d3.max(flatValues) - d3.min(flatValues));
                            const color = this.getContourColor(normalizedValue);
                            
                            const material = new THREE.LineBasicMaterial({
                                color: color,
                                linewidth: 1
                            });

                            const line = new THREE.Line(geometry, material);
                            this.group.add(line);
                        });
                    });
                });
            }

            getContourColor(normalizedValue) {
                // 使用 d3 的颜色比例尺
                const colorScale = d3.scaleSequential(d3.interpolateRdYlBu)
                    .domain([1, 0]); // 反转域以匹配 plotly 的颜色方案
                
                return new THREE.Color(colorScale(normalizedValue));
            }

            createGrid() {
                const xMin = this.data.x[0];
                const xMax = this.data.x[this.data.x.length - 1];
                const yMin = this.data.y[0];
                const yMax = this.data.y[this.data.y.length - 1];

                // 创建网格线
                const gridMaterial = new THREE.LineBasicMaterial({
                    color: 0xcccccc,
                    opacity: 0.5,
                    transparent: true
                });

                // X 方向网格线
                for (let x of this.data.x) {
                    const points = [
                        new THREE.Vector3(x, yMin, 0),
                        new THREE.Vector3(x, yMax, 0)
                    ];
                    const geometry = new THREE.BufferGeometry().setFromPoints(points);
                    const line = new THREE.Line(geometry, gridMaterial);
                    this.group.add(line);
                }

                // Y 方向网格线
                for (let y of this.data.y) {
                    const points = [
                        new THREE.Vector3(xMin, y, 0),
                        new THREE.Vector3(xMax, y, 0)
                    ];
                    const geometry = new THREE.BufferGeometry().setFromPoints(points);
                    const line = new THREE.Line(geometry, gridMaterial);
                    this.group.add(line);
                }
            }

            createAxes() {
                const axesGroup = new THREE.Group();
                
                // X轴
                this.createAxis(
                    axesGroup,
                    this.data.x,
                    'x',
                    new THREE.Vector3(1, 0, 0),
                    this.width
                );
                
                // Y轴
                this.createAxis(
                    axesGroup,
                    this.data.y,
                    'y',
                    new THREE.Vector3(0, 1, 0),
                    this.height
                );

                this.group.add(axesGroup);
            }

            createAxis(group, values, axisType, direction, length) {
                // 创建轴线
                const axisGeometry = new THREE.BufferGeometry().setFromPoints([
                    new THREE.Vector3(0, 0, 0),
                    direction.multiplyScalar(length)
                ]);
                const axisMaterial = new THREE.LineBasicMaterial({ color: 0x000000 });
                const axis = new THREE.Line(axisGeometry, axisMaterial);
                group.add(axis);

                // 创建刻度标签
                values.forEach(value => {
                    const position = axisType === 'x' 
                        ? new THREE.Vector3(value, 0, 0)
                        : new THREE.Vector3(0, value, 0);
                    
                    // 刻度线
                    const tickGeometry = new THREE.BufferGeometry().setFromPoints([
                        position,
                        position.clone().add(new THREE.Vector3(
                            axisType === 'y' ? -0.5 : 0,
                            axisType === 'x' ? -0.5 : 0,
                            0
                        ))
                    ]);
                    const tick = new THREE.Line(tickGeometry, axisMaterial);
                    group.add(tick);

                    // 标签
                    const label = this.createAxisLabel(value.toFixed(1), position, axisType);
                    group.add(label);
                });
            }

            createAxisLabel(text, position, axisType) {
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 64;
                canvas.height = 32;

                context.fillStyle = 'black';
                context.font = '16px Arial';
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                context.fillText(text, canvas.width/2, canvas.height/2);

                const texture = new THREE.CanvasTexture(canvas);
                const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
                const sprite = new THREE.Sprite(spriteMaterial);

                const offset = 1;
                if (axisType === 'x') {
                    sprite.position.set(position.x, position.y - offset, 0);
                } else {
                    sprite.position.set(position.x - offset, position.y, 0);
                }

                sprite.scale.set(2, 1, 1);
                return sprite;
            }

            createValueTexture() {
                const width = this.data.v[0].length;
                const height = this.data.v.length;
                const data = new Float32Array(width * height);
                
                for (let i = 0; i < height; i++) {
                    for (let j = 0; j < width; j++) {
                        data[i * width + j] = this.data.v[i][j];
                    }
                }
                
                return data;
            }

            isValidCell(x, y) {
                return x >= 0 && x < this.data.v[0].length - 1 && 
                       y >= 0 && y < this.data.v.length - 1;
            }

            smoothPoints(points) {
                if (points.length < 3) return points;
                
                const smoothed = [];
                const tension = 0.25; // 平滑程度
                
                smoothed.push(points[0]);
                
                for (let i = 1; i < points.length - 1; i++) {
                    const prev = points[i - 1];
                    const curr = points[i];
                    const next = points[i + 1];
                    
                    const x = curr.x + tension * (next.x - prev.x) / 4;
                    const y = curr.y + tension * (next.y - prev.y) / 4;
                    
                    smoothed.push(new THREE.Vector3(x, y, 0));
                }
                
                smoothed.push(points[points.length - 1]);
                return smoothed;
            }
        }

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xffffff);

            // 使用正交相机以保持比例
            const width = container.clientWidth;
            const height = container.clientHeight;
            const aspect = width / height;
            const frustumSize = 10;

            camera = new THREE.OrthographicCamera(
                frustumSize * aspect / -2,
                frustumSize * aspect / 2,
                frustumSize / 2,
                frustumSize / -2,
                0.1,
                1000
            );
            camera.position.set(0, 0, 50);

            renderer = new THREE.WebGLRenderer({
                antialias: true,
                preserveDrawingBuffer: true
            });
            renderer.setSize(width, height);
            container.appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableRotate = false;
            controls.enableZoom = true;
            controls.enablePan = true;

            const testData = [{
                v: [[2, 4, 7, 12, 13, 14, 15, 16],
                    [3, 1, 6, 11, 12, 13, 16, 17],
                    [4, 2, 7, 7, 11, 14, 17, 18],
                    [5, 3, 8, 8, 13, 15, 18, 19],
                    [7, 4, 10, 9, 16, 18, 20, 19],
                    [9, 10, 5, 27, 23, 21, 21, 21],
                    [11, 14, 17, 26, 25, 24, 23, 22]],
                x: [0, 1, 2, 3, 4, 5, 6, 7],
                y: [0, 1, 2, 3, 4, 5, 6],
                type: 'contour',
                line: { smoothing: 0 },
                contours: { coloring: 'lines' }
            }];

            const contourPlot = new ContourPlot(testData);
            scene.add(contourPlot.group);

            window.addEventListener('resize', onWindowResize);
        }

        function onWindowResize() {
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        init();
        animate();

    </script>

</body>

</html>