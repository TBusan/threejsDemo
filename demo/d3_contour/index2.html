<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Three.js 等值线渲染</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <!-- <script src="https://threejs.org/build/three.min.js"></script>
    <script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script> -->
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: white;
            font-family: Arial, sans-serif;
        }
    </style>
</head>
<body>
    <div id="info">Three.js 等值线渲染 (从 D3.js 数据提取)</div>
    <div id="container"></div>
    <script type="importmap">
        {
            "imports": {
                "three": "../../build/three.module.js",
                "three/addons/": "../../examples/jsm/"
            }
        }
    </script>
    <script type="module">
        // ===== D3.js 部分：生成等值线数据 =====
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        // 配置参数
        const width = 800;
        const height = 600;
        const resolution = 256; // 纹理分辨率
        
        // 生成随机数据（高斯分布）
        const generateData = (n, mean, variance) => {
            return Array.from({ length: n }, () => {
                return [
                    mean[0] + d3.randomNormal(0, variance)(),
                    mean[1] + d3.randomNormal(0, variance)()
                ];
            });
        };

        // 创建混合数据集
        const data = [
            ...generateData(500, [0.3, 0.3], 0.1),
            ...generateData(300, [0.7, 0.7], 0.08),
            ...generateData(200, [0.4, 0.7], 0.05)
        ];

        // 创建密度计算器
        const density = d3.contourDensity()
            .x(d => d[0] * width)
            .y(d => d[1] * height)
            .size([width, height])
            .bandwidth(20)
            .thresholds(20);

        // 计算等值线
        const contours = density(data);
        
        // 颜色比例尺
        const colorScale = d3.scaleSequential()
            .domain(d3.extent(contours, d => d.value))
            .interpolator(d3.interpolateYlGnBu);
            
        // 创建离屏 Canvas 进行纹理渲染
        const textureCanvas = document.createElement('canvas');
        textureCanvas.width = resolution;
        textureCanvas.height = resolution;
        const ctx = textureCanvas.getContext('2d');
        
        // 清除背景
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0, 0, resolution, resolution);
        
        // 对 Canvas 进行缩放以匹配分辨率
        const scaleX = resolution / width;
        const scaleY = resolution / height;
        ctx.scale(scaleX, scaleY);
        
        // 绘制等值线到 Canvas
        const path = d3.geoPath().context(ctx);
        
        // 先绘制所有填充区域
        contours.forEach(d => {
            ctx.beginPath();
            path(d);
            ctx.fillStyle = colorScale(d.value);
            ctx.fill();
        });
        
        // 再绘制所有线条
        contours.forEach(d => {
            ctx.beginPath();
            path(d);
            ctx.strokeStyle = 'rgba(0,0,0,0.3)';
            ctx.lineWidth = 0.5;
            ctx.stroke();
        });
        
        // ===== Three.js 部分：3D 渲染 =====
        
        // 设置 Three.js 场景
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf0f0f0);
        
        // 设置摄像机
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 1.5);
        const renderer = new THREE.WebGLRenderer({ 
            antialias: true,
        });
        // 设置渲染器
        // const renderer = new THREE.WebGLRenderer({ 
        //     antialias: true,
        //     logarithmicDepthBuffer: true  // Add logarithmic depth buffer to solve Z-fighting
        // });
        // renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('container').appendChild(renderer.domElement);
        
        // 添加轨道控制
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.25;
        
        // 创建从 Canvas 纹理
        const texture = new THREE.CanvasTexture(textureCanvas);
        texture.needsUpdate = true;
        
        // 创建基础平面材质
        const material = new THREE.MeshBasicMaterial({ 
            map: texture,
            side: THREE.DoubleSide
        });
        
        // 创建平面几何体（保持1:1比例）
        const aspectRatio = width / height;
        const planeGeometry = new THREE.PlaneGeometry(1 * aspectRatio, 1);
        
        // 创建网格
        const plane = new THREE.Mesh(planeGeometry, material);
        scene.add(plane);
        
        // ===== 为每个等值线创建 3D 高程效果 =====
        
        // 获取每个等值线的高度值
        const heightScale = 0.05; // Reduce overall height
        const layerGap = 0.02;    // Add explicit layer spacing
        const minValue = d3.min(contours, d => d.value);
        const maxValue = d3.max(contours, d => d.value);
        
        // 对每个等值线创建挤压几何体
        contours.forEach((contour, i) => {
            // 将 D3 路径转换为 Three.js 形状
            const shape = new THREE.Shape();
            let started = false;
            
            // 提取路径点
            const coordinates = contour.coordinates;
            
            // 简化点集以减少复杂度
            const simplifiedPoints = simplifyPoints(coordinates[0][0], 0.5);
            
            simplifiedPoints.forEach((point, j) => {
                // 归一化坐标
                const x = (point[0] / width - 0.5) * aspectRatio;
                const y = -(point[1] / height - 0.5); // Y 坐标反转
                
                if (j === 0) {
                    shape.moveTo(x, y);
                } else {
                    shape.lineTo(x, y);
                }
            });
            
            // 创建挤压几何体
            const normalizedValue = (contour.value - minValue) / (maxValue - minValue);
            const extrudeSettings = {
                steps: 2, // Increase steps for smoother sides
                depth: normalizedValue * heightScale,
                bevelEnabled: false
            };
            
            const contourGeometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
            
            // 创建材质
            const contourMaterial = new THREE.MeshPhongMaterial({
                color: new THREE.Color(colorScale(contour.value)),
                transparent: true,
                opacity: 0.8,
                side: THREE.DoubleSide,
                depthWrite: true,       // Ensure depth writing
                polygonOffset: true,    // Enable polygon offset
                polygonOffsetFactor: 1, // Offset factor
                polygonOffsetUnits: 1   // Offset units
            });
            
            // 创建网格并添加到场景
            const contourMesh = new THREE.Mesh(contourGeometry, contourMaterial);
            contourMesh.position.z = layerGap * i; 
            scene.add(contourMesh);
        });
        
        // 添加光源
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(1, 1, 1);
        scene.add(directionalLight);
        
        // 添加坐标轴辅助
        const axesHelper = new THREE.AxesHelper(1);
        scene.add(axesHelper);
        
        // 窗口大小调整处理
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // 动画循环
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        
        animate();

        // Add point set simplification function
        function simplifyPoints(points, tolerance) {
            if (points.length <= 2) return points;
            
            // Simple distance function
            const distSquared = (p1, p2) => {
                const dx = p1[0] - p2[0];
                const dy = p1[1] - p2[1];
                return dx * dx + dy * dy;
            };
            
            const result = [points[0]];
            let lastPoint = points[0];
            
            for (let i = 1; i < points.length - 1; i++) {
                if (distSquared(points[i], lastPoint) > tolerance * tolerance) {
                    result.push(points[i]);
                    lastPoint = points[i];
                }
            }
            
            result.push(points[points.length - 1]);
            return result;
        }
    </script>
</body>
</html>