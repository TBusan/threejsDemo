<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Three.js 渲染D3.js等值线图</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }
        canvas {
            display: block;
        }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: white;
            font-family: Arial, sans-serif;
        }
        #controls {
            position: absolute;
            top: 40px;
            left: 10px;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            color: white;
            font-family: Arial, sans-serif;
        }
        #colorScale {
            margin-top: 10px;
            width: 300px;
            height: 30px;
            position: relative;
        }
    </style>
</head>
<body>
    <div id="info">D3等值线数据 + Three.js渲染</div>
    <div id="controls">
        <div>
            <label><input type="checkbox" id="showContourLines" checked />显示等值线轮廓</label>
        </div>
        <div>
            <label><input type="checkbox" id="showContourLabels" />显示等值线标注</label>
        </div>
        <div id="colorScale"></div>
    </div>
    <div id="container"></div>

    <script type="importmap">
        {
            "imports": {
                "three": "../../build/three.module.js",
                "three/addons/": "../../examples/jsm/"
            }
        }
    </script>

    <script type="module">
        // 导入必要的库
        import * as THREE from "three";
        import { OrbitControls } from "three/addons/controls/OrbitControls.js";
        import Stats from "three/addons/libs/stats.module.js";
        import { contourData } from "./contourData2.js";

        // ===== D3.js 部分：生成等值线数据 =====
        // 配置参数
        const width = 800;
        const height = 600;
        const aspectRatio = width / height;
        
        // 控制参数
        let showContourLines = true; // 显示等值线轮廓
        let showContourLabels = false; // 显示等值线标注

        // 解析contourData数据
        const dataX = contourData.data.x; // X坐标数组
        const dataY = contourData.data.y; // Y坐标数组
        const dataValues = contourData.data.v; // 值的二维数组
        const zMin = contourData.data.zmin; // 最小值
        const zMax = contourData.data.zmax; // 最大值
        
        // 获取数据网格尺寸
        const gridSizeX = dataX.length;
        const gridSizeY = dataY.length;
        
        // 创建一维数组来存储数据，以供D3使用
        const gridData = new Array(gridSizeY * gridSizeX);
        
        // 处理contourData中的数据，转换为D3可用的格式
        function processContourData() {
            // 将二维数组扁平化为一维
            for (let y = 0; y < gridSizeY; y++) {
                for (let x = 0; x < gridSizeX; x++) {
                    const value = dataValues[y][x];
                    
                    // null值处理：将null值替换为undefined，让D3自动跳过这些区域
                    if (value === null) {
                        gridData[y * gridSizeX + x] = undefined;
                    } else {
                        gridData[y * gridSizeX + x] = value;
                    }
                }
            }
            
            return gridData;
        }
        
        // 生成地形数据
        const processedGridData = processContourData();
        
        // 基于数据范围自动生成等值线阈值
        const valueRange = zMax - zMin;
        const thresholdCount = 20;
        const thresholds = [];
        
        // 添加特定阈值
        const specificThresholds = [-1000, 0, 100, 200, 300, 400, 500, 1000];
        
        // 首先添加特定阈值
        specificThresholds.forEach(val => {
            if (val >= zMin && val <= zMax && !thresholds.includes(val)) {
                thresholds.push(val);
            }
        });
        
        // 然后添加均匀分布的阈值
        for (let i = 1; i <= thresholdCount; i++) {
            const val = zMin + (valueRange * i) / (thresholdCount + 1);
            // 避免与特定阈值太接近
            const isTooClose = specificThresholds.some(specific => 
                Math.abs(val - specific) < valueRange / 40);
            if (!isTooClose) {
                thresholds.push(val);
            }
        }
        
        // 对阈值进行排序
        thresholds.sort((a, b) => a - b);

        console.log('thresholds==',thresholds);
        
        // 使用d3.contours()从处理后的网格数据生成等值线
        const contourGenerator = d3
            .contours()
            .size([gridSizeX, gridSizeY])
            .thresholds(specificThresholds)
            .smooth(true); // 启用平滑处理
            
        // 计算等值线
        let contours = contourGenerator(processedGridData);

        console.log('==contours==',contours);
        
        // 颜色比例尺 - 使用紫蓝色系
        function getTerrainColor(value) {
            // 根据数据范围创建颜色映射
            const minVal = zMin;
            const maxVal = zMax;
            const step = (maxVal - minVal) / 4;
            
            // 使用紫蓝色系
            const localOriginColor = [
                [minVal, "rgba(76,29,143,255)"],       // 深紫色
                [minVal + step*1, "rgba(85,53,201,255)"],    // 紫色
                [minVal + step*2, "rgba(73,63,189,255)"],    // 蓝紫色
                [minVal + step*3, "rgba(56,93,220,255)"],    // 紫蓝色
                [maxVal, "rgba(66,114,245,255)"]            // 蓝色
            ];
            
            const localOriginColorLen = localOriginColor.length;
            const localOriginColorMin = localOriginColor[0][0];
            const localOriginColorMax = localOriginColor[localOriginColorLen - 1][0];

            if (value <= localOriginColorMin) {
                return localOriginColor[0][1];
            } else if (value >= localOriginColorMax) {
                return localOriginColor[localOriginColorLen - 1][1];
            } else {
                for (let i = 0; i < localOriginColorLen - 1; i++) {
                    if (value >= localOriginColor[i][0] && value < localOriginColor[i + 1][0]) {
                        return localOriginColor[i][1];
                    }
                }
                return localOriginColor[0][1];
            }
        }

        // 解析颜色字符串为THREE.Color
        function parseColor(colorStr) {
            const rgba = colorStr.match(/\d+/g).map(Number);
            return new THREE.Color(rgba[0]/255, rgba[1]/255, rgba[2]/255);
        }

        // ===== Three.js 部分：3D 渲染 =====
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x222222);

        // 设置摄像机
        const camera = new THREE.PerspectiveCamera(
            60,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
        );
        camera.position.set(0, 0, 1.5);

        // 创建渲染器
        const renderer = new THREE.WebGLRenderer({
            antialias: true,
            logarithmicDepthBuffer: true, // 启用对数深度缓冲解决Z-fighting
        });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.sortObjects = true;
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById("container").appendChild(renderer.domElement);

        // 添加轨道控制
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.25;

        // 添加性能监视器
        const stats = new Stats();
        stats.domElement.style.position = "absolute";
        stats.domElement.style.top = "0px";
        document.getElementById("container").appendChild(stats.domElement);

        // 保存所有等值线网格的引用，以便更新
        const contourMeshes = [];
        const contourLabels = []; // 保存等值线标注的引用

        // 材质缓存，避免重复创建
        const materialCache = new Map();

        // 获取或创建材质
        function getMaterial(color, isLine = false, renderIndex = 0) {
            const key = color.toString() + (isLine ? "_line" : "_mesh") + "_" + renderIndex;

            if (materialCache.has(key)) {
                return materialCache.get(key);
            }

            let material;
            if (isLine) {
                // 检查是否是特定轮廓值（100,200,300等）
                const isSpecificContour = specificThresholds.includes(parseFloat(renderIndex));

                material = new THREE.LineBasicMaterial({
                    color: color,
                    linewidth: isSpecificContour ? 3 : 1,
                    depthTest: false,
                    depthWrite: false,
                    transparent: true,
                    opacity: isSpecificContour ? 1.0 : 0.8,
                });
            } else {
                material = new THREE.MeshBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: 0.8,
                    side: THREE.DoubleSide,
                    depthWrite: false,
                    depthTest: true,
                });
            }

            materialCache.set(key, material);
            return material;
        }

        // 创建等值线
        function createContours() {
            // 清除现有的等值线网格
            contourMeshes.forEach(mesh => {
                scene.remove(mesh);
                if (mesh.geometry) mesh.geometry.dispose();
                if (mesh.material) mesh.material.dispose();
            });
            contourMeshes.length = 0;

            // 清除现有的标注
            contourLabels.forEach(label => {
                scene.remove(label);
                if (label.geometry) label.geometry.dispose();
                if (label.material) label.material.dispose();
            });
            contourLabels.length = 0;

            // 清空材质缓存
            materialCache.clear();

            // 确保从低值到高值的顺序处理等值线 - 先进行排序
            const sortedContours = [...contours].sort((a, b) => a.value - b.value);
            
            // 统一处理等值线 - 同时创建面和线，确保一致性
            for (let i = 0; i < sortedContours.length; i++) {
                const contour = sortedContours[i];
                
                // 创建等值线的形状
                for (const polygon of contour.coordinates) {
                    const shape = new THREE.Shape();
                    
                    // 遍历轮廓线的点，转换到Three.js坐标系
                    for (let j = 0; j < polygon[0].length; j++) {
                        const [x, y] = polygon[0][j];
                        
                        // 转换数据坐标到场景坐标
                        const normalizedX = (x / (gridSizeX - 1)) - 0.5;
                        const normalizedY = (y / (gridSizeY - 1)) - 0.5;
                        const sceneX = normalizedX * aspectRatio;
                        const sceneY = -normalizedY; // Y轴翻转
                        
                        if (j === 0) {
                            shape.moveTo(sceneX, sceneY);
                        } else {
                            shape.lineTo(sceneX, sceneY);
                        }
                    }
                    
                    // 闭合形状
                    shape.closePath();
                    
                    // 处理内部孔洞
                    for (let j = 1; j < polygon.length; j++) {
                        const hole = new THREE.Path();
                        
                        for (let k = 0; k < polygon[j].length; k++) {
                            const [x, y] = polygon[j][k];
                            
                            // 转换数据坐标到场景坐标
                            const normalizedX = (x / (gridSizeX - 1)) - 0.5;
                            const normalizedY = (y / (gridSizeY - 1)) - 0.5;
                            const sceneX = normalizedX * aspectRatio;
                            const sceneY = -normalizedY; // Y轴翻转
                            
                            if (k === 0) {
                                hole.moveTo(sceneX, sceneY);
                            } else {
                                hole.lineTo(sceneX, sceneY);
                            }
                        }
                        
                        shape.holes.push(hole);
                    }
                    
                    // 创建几何体，增加细分以获得更平滑的形状
                    const geometry = new THREE.ShapeGeometry(shape, 32);
                    
                    // 获取当前等值线的颜色
                    const colorStr = getTerrainColor(contour.value);
                    const color = parseColor(colorStr);
                    
                    // 创建材质和网格
                    const material = getMaterial(color, false, contour.value);
                    const mesh = new THREE.Mesh(geometry, material);
                    
                    // 设置z位置和渲染顺序，确保较高的等值线绘制在较低的上面
                    const zOffset = 0.0001 * i;
                    mesh.position.z = zOffset;
                    mesh.renderOrder = i;
                    
                    // 添加到场景
                    scene.add(mesh);
                    contourMeshes.push(mesh);
                    
                    // 如果需要显示等值线轮廓
                    if (showContourLines) {
                        // 检查是否是特定值的等值线
                        const isSpecificValue = specificThresholds.includes(contour.value);
                        
                        // 创建线条几何体
                        const lineGeometry = new THREE.EdgesGeometry(geometry);
                        const lineMaterial = getMaterial(
                            isSpecificValue ? 0xFFFFFF : 0x888888, 
                            true, 
                            contour.value
                        );
                        const line = new THREE.LineSegments(lineGeometry, lineMaterial);
                        
                        // 设置z位置和渲染顺序，确保线条绘制在面的上面
                        line.position.z = zOffset + 0.0001;
                        line.renderOrder = i + sortedContours.length;
                        
                        // 添加到场景
                        scene.add(line);
                        contourMeshes.push(line);
                    }
                    
                    // 如果需要显示等值线标注
                    if (showContourLabels) {
                        // 获取形状的边界框
                        const bbox = new THREE.Box3();
                        const points = shape.getPoints(16);
                        const tempGeometry = new THREE.BufferGeometry().setFromPoints(points);
                        bbox.setFromBufferAttribute(tempGeometry.attributes.position);
                        tempGeometry.dispose();
                        
                        // 计算标注位置 - 在形状中心
                        const centerX = (bbox.min.x + bbox.max.x) / 2;
                        const centerY = (bbox.min.y + bbox.max.y) / 2;
                        
                        // 创建标注
                        const canvas = document.createElement('canvas');
                        canvas.width = 128;
                        canvas.height = 64;
                        const ctx = canvas.getContext('2d');
                        
                        // 设置文本
                        ctx.fillStyle = isSpecificValue ? 'white' : '#AAAAAA';
                        ctx.font = isSpecificValue ? 'bold 28px Arial' : '20px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        
                        // 绘制文本
                        const text = contour.value.toFixed(isSpecificValue ? 0 : 1);
                        ctx.fillText(text, canvas.width / 2, canvas.height / 2);
                        
                        // 创建纹理
                        const texture = new THREE.CanvasTexture(canvas);
                        texture.needsUpdate = true;
                        
                        // 创建标注材质
                        const labelMaterial = new THREE.SpriteMaterial({
                            map: texture,
                            transparent: true,
                            depthTest: false,
                            depthWrite: false
                        });
                        
                        // 创建标注精灵
                        const label = new THREE.Sprite(labelMaterial);
                        label.position.set(centerX, centerY, zOffset + 0.01);
                        
                        // 设置标注大小
                        const labelScale = isSpecificValue ? 0.1 : 0.07;
                        label.scale.set(labelScale * aspectRatio, labelScale, 1);
                        
                        // 设置渲染顺序
                        label.renderOrder = 1000 + i;
                        
                        // 添加到场景
                        scene.add(label);
                        contourLabels.push(label);
                    }
                }
            }

            // 添加数据区域边界框 - 确保始终显示，不受showContourLines选项影响
            const borderPoints = [
                new THREE.Vector3(-aspectRatio/2, -0.5, 0),
                new THREE.Vector3(aspectRatio/2, -0.5, 0),
                new THREE.Vector3(aspectRatio/2, 0.5, 0),
                new THREE.Vector3(-aspectRatio/2, 0.5, 0),
                new THREE.Vector3(-aspectRatio/2, -0.5, 0)
            ];
            
            const borderGeometry = new THREE.BufferGeometry().setFromPoints(borderPoints);
            const borderMaterial = new THREE.LineBasicMaterial({
                color: 0xffffff,
                linewidth: 3, // 增加线宽
                transparent: true,
                opacity: 1.0,
                depthTest: false,
                depthWrite: false
            });
            
            const borderLine = new THREE.Line(borderGeometry, borderMaterial);
            borderLine.position.z = 0.01; // 确保边界显示在所有等值线上面
            borderLine.renderOrder = 4000; // 给边界更高的渲染优先级
            
            scene.add(borderLine);
            contourMeshes.push(borderLine);
            
            // 创建数据最小值的外围轮廓 - 确保整个数据区域被包含
            createOuterBoundary();
        }
        
        // 创建数据区域的外围轮廓
        function createOuterBoundary() {
            // 创建一个稍微大一点的矩形作为外围边界
            const outerShape = new THREE.Shape();
            const padding = 0.02; // 边界内边距
            
            // 稍微扩大一点的矩形边界
            outerShape.moveTo(-aspectRatio/2 - padding, -0.5 - padding);
            outerShape.lineTo(aspectRatio/2 + padding, -0.5 - padding);
            outerShape.lineTo(aspectRatio/2 + padding, 0.5 + padding);
            outerShape.lineTo(-aspectRatio/2 - padding, 0.5 + padding);
            outerShape.closePath();
            
            // 创建内部孔洞 - 与数据区域大小相同
            const innerHole = new THREE.Path();
            innerHole.moveTo(-aspectRatio/2, -0.5);
            innerHole.lineTo(aspectRatio/2, -0.5);
            innerHole.lineTo(aspectRatio/2, 0.5);
            innerHole.lineTo(-aspectRatio/2, 0.5);
            innerHole.closePath();
            
            // 添加孔洞到外围形状
            outerShape.holes.push(innerHole);
            
            // 创建几何体
            const geometry = new THREE.ShapeGeometry(outerShape, 32);
            
            // 使用最小值的颜色
            const minColor = parseColor(getTerrainColor(zMin));
            
            // 创建材质
            const material = new THREE.MeshBasicMaterial({
                color: minColor,
                transparent: true,
                opacity: 0.5,
                side: THREE.DoubleSide,
                depthWrite: false
            });
            
            // 创建网格
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.z = -0.001; // 确保在所有等值线下面
            mesh.renderOrder = -1;
            
            // 添加到场景
            scene.add(mesh);
            contourMeshes.push(mesh);
            
            // 添加轮廓线 - 只有在显示等值线轮廓时才显示
            if (showContourLines) {
                const lineGeometry = new THREE.EdgesGeometry(geometry);
                const lineMaterial = new THREE.LineBasicMaterial({
                    color: 0xFFFFFF,
                    linewidth: 2,
                    transparent: true,
                    opacity: 0.8,
                    depthTest: false,
                    depthWrite: false
                });
                
                const line = new THREE.LineSegments(lineGeometry, lineMaterial);
                line.position.z = 0.005; // 确保在其他等值线上面
                line.renderOrder = 3500;
                
                scene.add(line);
                contourMeshes.push(line);
            }
        }

        // 创建颜色图例
        function createColorLegend() {
            const legendContainer = document.getElementById('colorScale');
            legendContainer.innerHTML = '';
            legendContainer.style.position = 'relative';
            legendContainer.style.height = '20px';
            legendContainer.style.width = '100%';
            legendContainer.style.marginTop = '10px';
            
            // 更新颜色图例以匹配新的颜色方案
            legendContainer.style.background = 'linear-gradient(to right, rgba(76,29,143,255), rgba(85,53,201,255), rgba(73,63,189,255), rgba(56,93,220,255), rgba(66,114,245,255))';
            
            // 添加最小值和最大值标签
            const minLabel = document.createElement('div');
            minLabel.style.position = 'absolute';
            minLabel.style.left = '0';
            minLabel.style.top = '20px';
            minLabel.style.fontSize = '12px';
            minLabel.style.color = 'white';
            minLabel.textContent = zMin.toFixed(1);
            legendContainer.appendChild(minLabel);
            
            const maxLabel = document.createElement('div');
            maxLabel.style.position = 'absolute';
            maxLabel.style.right = '0';
            maxLabel.style.top = '20px';
            maxLabel.style.fontSize = '12px';
            maxLabel.style.color = 'white';
            maxLabel.textContent = zMax.toFixed(1);
            legendContainer.appendChild(maxLabel);
            
            // 添加中间值
            const midLabel = document.createElement('div');
            midLabel.style.position = 'absolute';
            midLabel.style.left = '50%';
            midLabel.style.transform = 'translateX(-50%)';
            midLabel.style.top = '20px';
            midLabel.style.fontSize = '12px';
            midLabel.style.color = 'white';
            midLabel.textContent = ((zMax + zMin) / 2).toFixed(1);
            legendContainer.appendChild(midLabel);
        }

        // 添加光源
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(1, 1, 1);
        scene.add(directionalLight);

        // 初始化
        createContours();
        createColorLegend();

        // UI事件监听
        document.getElementById("showContourLines").addEventListener("change", event => {
            showContourLines = event.target.checked;
            createContours(); // 重新创建等值线
        });

        document.getElementById("showContourLabels").addEventListener("change", event => {
            showContourLabels = event.target.checked;
            createContours(); // 重新创建等值线和标注
        });

        // 窗口大小调整处理
        window.addEventListener("resize", () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // 动画循环
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
            stats.update();
        }

        animate();
    </script>
</body>
</html>