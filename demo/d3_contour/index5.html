<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Three.js 渲染D3.js等值线图</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }
        canvas {
            display: block;
        }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: white;
            font-family: Arial, sans-serif;
        }
        #controls {
            position: absolute;
            top: 40px;
            left: 10px;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            color: white;
            font-family: Arial, sans-serif;
        }
        #colorScale {
            margin-top: 10px;
            width: 300px;
            height: 30px;
            position: relative;
        }
    </style>
</head>
<body>
    <div id="info">D3等值线数据 + Three.js渲染</div>
    <div id="controls">
        <div>
            <label><input type="checkbox" id="showContourLines" checked />显示等值线轮廓</label>
        </div>
    </div>
    <div id="container"></div>

    <script type="importmap">
        {
            "imports": {
                "three": "../../build/three.module.js",
                "three/addons/": "../../examples/jsm/"
            }
        }
    </script>

    <script type="module">
        // 导入必要的库
        import * as THREE from "three";
        import { OrbitControls } from "three/addons/controls/OrbitControls.js";
        import Stats from "three/addons/libs/stats.module.js";
        import { contourData } from "./contourData.js";

        // ===== D3.js 部分：生成等值线数据 =====
        // 配置参数
        const width = 800;
        const height = 600;
        const aspectRatio = width / height;
        
        // 控制参数
        let showContourLines = true; // 显示等值线轮廓
        let showContourLabels = false; // 显示等值线标注

        // 解析contourData数据
        const dataX = contourData.data.x; // X坐标数组
        const dataY = contourData.data.y; // Y坐标数组
        const dataValues = contourData.data.v; // 值的二维数组
        const zMin = contourData.data.zmin; // 最小值
        const zMax = contourData.data.zmax; // 最大值
        
        // 获取数据网格尺寸
        const gridSizeX = dataX.length;
        const gridSizeY = dataY.length;
        
        // 创建一维数组来存储数据，以供D3使用
        const gridData = new Array(gridSizeY * gridSizeX);
        
        // 处理contourData中的数据，转换为D3可用的格式
        function processContourData() {
            // 将二维数组扁平化为一维
            for (let y = 0; y < gridSizeY; y++) {
                for (let x = 0; x < gridSizeX; x++) {
                    const value = dataValues[y][x];
                    
                    // null值处理：将null值替换为undefined，让D3自动跳过这些区域
                    if (value === null) {
                        gridData[y * gridSizeX + x] = undefined;
                    } else {
                        gridData[y * gridSizeX + x] = value;
                    }
                }
            }
            
            return gridData;
        }
        
        // 获取实际的数据范围
        const xMin = d3.min(dataX);
        const xMax = d3.max(dataX);
        const yMin = d3.min(dataY);
        const yMax = d3.max(dataY);
        
        // 计算数据的真实长宽比
        const dataAspectRatio = (xMax - xMin) / Math.abs(yMax - yMin);
        
        console.log(`X范围: ${xMin} 到 ${xMax}, Y范围: ${yMin} 到 ${yMax}`);
        console.log(`数据长宽比: ${dataAspectRatio.toFixed(2)}`);
        
        // 计算THREE.js场景中的坐标范围，保持数据比例
        // 以Y轴为基准，X轴根据实际数据比例调整
        const sceneHeight = 1.0; // THREE.js场景中y轴的总高度
        const sceneWidth = sceneHeight * dataAspectRatio; // 按数据比例计算x轴宽度
        
        // 调整相机位置以适应新的场景比例
        const cameraDistance = Math.max(dataAspectRatio, 2) * 1.2; // 确保能看到整个场景
        
        // 创建比例尺 - 使用准确的数据范围和比例
        const xScale = d3.scaleLinear()
            .domain([xMin, xMax])
            .range([-sceneWidth/2, sceneWidth/2]);
            
        const yScale = d3.scaleLinear()
            .domain([yMin, yMax])
            .range([sceneHeight/2, -sceneHeight/2]); // Y轴翻转，因为Three.js和屏幕坐标Y轴方向相反
        
        // 生成地形数据
        const processedGridData = processContourData();
        
        // 基于数据范围自动生成等值线阈值
        const valueRange = zMax - zMin;
        const thresholdCount = 20;
        const thresholds = [];
        
        // 添加特定阈值
        const specificThresholds = [-1000, 0, 100, 200, 300, 400, 500, 1000];
        
        // 使用d3.contours()从处理后的网格数据生成等值线
        const contourGenerator = d3
            .contours()
            .size([gridSizeX, gridSizeY])
            .thresholds(specificThresholds)
            .smooth(true); // 启用平滑处理
            
        // 计算等值线
        let contours = contourGenerator(processedGridData);

        console.log('==contours==',contours);
        
        // 颜色比例尺 - 使用紫蓝色系
        function getTerrainColor(value) {
            // 根据数据范围创建颜色映射
            const minVal = zMin;
            const maxVal = zMax;
            const step = (maxVal - minVal) / 4;
            
            // 使用紫蓝色系
            const localOriginColor = [
                [minVal, "rgba(76,29,143,255)"],             // 深紫色
                [minVal + step*1, "rgba(85,53,201,255)"],    // 紫色
                [minVal + step*2, "rgba(73,63,189,255)"],    // 蓝紫色
                [minVal + step*3, "rgba(56,93,220,255)"],    // 紫蓝色
                [maxVal, "rgba(66,114,245,255)"]             // 蓝色
            ];
            
            const localOriginColorLen = localOriginColor.length;
            const localOriginColorMin = localOriginColor[0][0];
            const localOriginColorMax = localOriginColor[localOriginColorLen - 1][0];

            if (value <= localOriginColorMin) {
                return localOriginColor[0][1];
            } else if (value >= localOriginColorMax) {
                return localOriginColor[localOriginColorLen - 1][1];
            } else {
                for (let i = 0; i < localOriginColorLen - 1; i++) {
                    if (value >= localOriginColor[i][0] && value < localOriginColor[i + 1][0]) {
                        return localOriginColor[i][1];
                    }
                }
                return localOriginColor[0][1];
            }
        }

        // 解析颜色字符串为THREE.Color
        function parseColor(colorStr) {
            const rgba = colorStr.match(/\d+/g).map(Number);
            return new THREE.Color(rgba[0]/255, rgba[1]/255, rgba[2]/255);
        }

        // ===== Three.js 部分：3D 渲染 =====
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x222222);

        // 设置摄像机
        const camera = new THREE.PerspectiveCamera(
            60,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
        );
        camera.position.set(0, 0, cameraDistance);

        // 创建渲染器
        const renderer = new THREE.WebGLRenderer({
            antialias: true,
            logarithmicDepthBuffer: true, // 启用对数深度缓冲解决Z-fighting
        });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.sortObjects = true;
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById("container").appendChild(renderer.domElement);

        // 添加轨道控制
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.25;

        // 添加性能监视器
        const stats = new Stats();
        stats.domElement.style.position = "absolute";
        stats.domElement.style.top = "0px";
        document.getElementById("container").appendChild(stats.domElement);

        // 保存所有等值线网格的引用，以便更新
        const contourMeshes = [];
        const contourLabels = []; // 保存等值线标注的引用

        // 材质缓存，避免重复创建
        const materialCache = new Map();

        // 获取或创建材质
        function getMaterial(color, isLine = false, renderIndex = 0) {
            const key = color.toString() + (isLine ? "_line" : "_mesh") + "_" + renderIndex;

            if (materialCache.has(key)) {
                return materialCache.get(key);
            }

            let material;
            if (isLine) {
                // 检查是否是特定轮廓值（100,200,300等）
                const isSpecificContour = specificThresholds.includes(parseFloat(renderIndex));

                material = new THREE.LineBasicMaterial({
                    color: color,
                    linewidth: isSpecificContour ? 3 : 1,
                    depthTest: false,
                    depthWrite: false,
                    transparent: true,
                    opacity: isSpecificContour ? 1.0 : 0.8,
                });
            } else {
                material = new THREE.MeshBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: 0.8,
                    side: THREE.DoubleSide,
                    depthWrite: false,
                    depthTest: true,
                });
            }

            materialCache.set(key, material);
            return material;
        }

        // 创建等值线
        function createContours() {
            // 清除现有的等值线网格
            contourMeshes.forEach(mesh => {
                scene.remove(mesh);
                if (mesh.geometry) mesh.geometry.dispose();
                if (mesh.material) mesh.material.dispose();
            });
            contourMeshes.length = 0;

            // 清除现有的标注
            contourLabels.forEach(label => {
                scene.remove(label);
                if (label.geometry) label.geometry.dispose();
                if (label.material) label.material.dispose();
            });
            contourLabels.length = 0;

            // 清空材质缓存
            materialCache.clear();

            // 确保从低值到高值的顺序处理等值线 - 先进行排序
            const sortedContours = [...contours].sort((a, b) => a.value - b.value);
            
            // 统一处理等值线 - 同时创建面和线，确保一致性
            for (let i = 0; i < sortedContours.length; i++) {
                const contour = sortedContours[i];
                
                // 创建等值线的形状
                for (const polygon of contour.coordinates) {
                    const shape = new THREE.Shape();
                    
                    // 遍历轮廓线的点，转换到Three.js坐标系
                    for (let j = 0; j < polygon[0].length; j++) {
                        const [x, y] = polygon[0][j];
                        
                        // 转换D3网格坐标到数据坐标
                        const dataXPos = xMin + (x / (gridSizeX - 1)) * (xMax - xMin);
                        const dataYPos = yMin + (y / (gridSizeY - 1)) * (yMax - yMin);
                        
                        // 使用比例尺将数据坐标转换到场景坐标
                        const sceneX = xScale(dataXPos);
                        const sceneY = yScale(dataYPos);
                        
                        if (j === 0) {
                            shape.moveTo(sceneX, sceneY);
                        } else {
                            shape.lineTo(sceneX, sceneY);
                        }
                    }
                    
                    // 闭合形状
                    shape.closePath();
                    
                    // 处理内部孔洞
                    for (let j = 1; j < polygon.length; j++) {
                        const hole = new THREE.Path();
                        
                        for (let k = 0; k < polygon[j].length; k++) {
                            const [x, y] = polygon[j][k];
                            
                            // 转换D3网格坐标到数据坐标
                            const dataXPos = xMin + (x / (gridSizeX - 1)) * (xMax - xMin);
                            const dataYPos = yMin + (y / (gridSizeY - 1)) * (yMax - yMin);
                            
                            // 使用比例尺将数据坐标转换到场景坐标
                            const sceneX = xScale(dataXPos);
                            const sceneY = yScale(dataYPos);
                            
                            if (k === 0) {
                                hole.moveTo(sceneX, sceneY);
                            } else {
                                hole.lineTo(sceneX, sceneY);
                            }
                        }
                        
                        shape.holes.push(hole);
                    }
                    
                    // 创建几何体，增加细分以获得更平滑的形状
                    const geometry = new THREE.ShapeGeometry(shape, 32);
                    
                    // 获取当前等值线的颜色
                    const colorStr = getTerrainColor(contour.value);
                    const color = parseColor(colorStr);
                    
                    // 创建材质和网格
                    const material = getMaterial(color, false, contour.value);
                    const mesh = new THREE.Mesh(geometry, material);
                    
                    // 设置z位置和渲染顺序，确保较高的等值线绘制在较低的上面
                    const zOffset = 0.0001 * i;
                    mesh.position.z = zOffset;
                    mesh.renderOrder = i;
                    
                    // 添加到场景
                    scene.add(mesh);
                    contourMeshes.push(mesh);
                    
                    // 如果需要显示等值线轮廓
                    if (showContourLines) {
                        // 检查是否是特定值的等值线
                        const isSpecificValue = specificThresholds.includes(contour.value);
                        
                        // 创建线条几何体
                        const lineGeometry = new THREE.EdgesGeometry(geometry);
                        const lineMaterial = getMaterial(
                            isSpecificValue ? 0xFFFFFF : 0x888888, 
                            true, 
                            contour.value
                        );
                        const line = new THREE.LineSegments(lineGeometry, lineMaterial);
                        
                        // 设置z位置和渲染顺序，确保线条绘制在面的上面
                        line.position.z = zOffset + 0.0001;
                        line.renderOrder = i + sortedContours.length;
                        
                        // 添加到场景
                        scene.add(line);
                        contourMeshes.push(line);
                    }
                    
                }
            }

            // 添加数据区域边界框 - 确保始终显示，不受showContourLines选项影响
            const borderPoints = [
                new THREE.Vector3(-aspectRatio/2, -0.5, 0),
                new THREE.Vector3(aspectRatio/2, -0.5, 0),
                new THREE.Vector3(aspectRatio/2, 0.5, 0),
                new THREE.Vector3(-aspectRatio/2, 0.5, 0),
                new THREE.Vector3(-aspectRatio/2, -0.5, 0)
            ];
            
            const borderGeometry = new THREE.BufferGeometry().setFromPoints(borderPoints);
            const borderMaterial = new THREE.LineBasicMaterial({
                color: 0xffffff,
                linewidth: 3, // 增加线宽
                transparent: true,
                opacity: 1.0,
                depthTest: false,
                depthWrite: false
            });
            
            const borderLine = new THREE.Line(borderGeometry, borderMaterial);
            borderLine.position.z = 0.01; // 确保边界显示在所有等值线上面
            borderLine.renderOrder = 4000; // 给边界更高的渲染优先级
            
            scene.add(borderLine);
            contourMeshes.push(borderLine);
            
        }
        
 
    
        // 添加光源
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(1, 1, 1);
        scene.add(directionalLight);

        // 初始化
        createContours();


        // UI事件监听
        document.getElementById("showContourLines").addEventListener("change", event => {
            showContourLines = event.target.checked;
            createContours(); // 重新创建等值线
        });

 

        // 窗口大小调整处理
        window.addEventListener("resize", () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // 动画循环
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
            stats.update();
        }

        animate();
    </script>
</body>
</html>