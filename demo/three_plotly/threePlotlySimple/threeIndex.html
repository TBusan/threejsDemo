<!DOCTYPE html>
<html lang="en">

<head>
    <title>Three.js Plotly Contour</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body { margin: 0; }
        #container { width: 1000px; height: 1000px; }
        #plotly-temp { position: absolute; top: 0; left: 0; opacity: 0.5; }
    </style>
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
</head>

<body>
    <div id="container"></div>
    <div id="plotly-temp"></div>

    <script type="importmap">
        {
            "imports": {
                "three": "../../../build/three.module.js",
                "three/addons/": "../../../examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        const data = {
            z: [[2, 4, 7, 12, 13, 14, 15, 16],
                [3, 1, 6, 11, 12, 13, 16, 17],
                [4, 2, 7, 7, 11, 14, 17, 18],
                [5, 3, 8, 8, 13, 15, 18, 19],
                [7, 4, 10, 9, 16, 18, 20, 19],
                [9, 10, 5, 27, 23, 21, 21, 21],
                [11, 14, 17, 26, 25, 24, 23, 22]],
            x: [0, 1, 2, 3, 4, 5, 6, 7],
            y: [0, 1, 2, 3, 4, 5, 6]
        };

        const plotlyData = [{
            type: 'contour',
            z: data.z,
            x: data.x,
            y: data.y,
            contours: {
                coloring: 'heatmap',
                showlabels: true,
                labelfont: { size: 12, color: 'white' }
            },
            colorscale: 'Viridis',
            showscale: false
        }];

        const layout = {
            width: 1000,
            height: 1000,
            margin: { t: 0, r: 0, b: 0, l: 0 },
            xaxis: { range: [0, 7] },
            yaxis: { range: [0, 6] }
        };

        const container = document.getElementById('container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xffffff);

        const width = container.clientWidth;
        const height = container.clientHeight;
        const camera = new THREE.OrthographicCamera(
            0, width,
            height, 0,
            -1000, 1000
        );
        camera.position.z = 100;

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(width, height);
        container.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableRotate = false;

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        animate();

        Plotly.newPlot('plotly-temp', plotlyData, layout).then(() => {
            console.log('Plotly rendered');
            
            setTimeout(() => {
                const plotlyContainer = document.getElementById('plotly-temp');
                const contourLayer = plotlyContainer.querySelector('.contour');
                
                if (!contourLayer) {
                    console.error('Cannot find contour layer');
                    return;
                }

                const fills = contourLayer.querySelectorAll('path.js-fill');
                console.log('Found fills:', fills.length);

                fills.forEach((path, index) => {
                    const color = path.getAttribute('fill');
                    const d = path.getAttribute('d');
                    console.log(`Processing path ${index}:`, { color, d });

                    if (!d) return;

                    const shape = new THREE.Shape();
                    const commands = d.match(/[a-zA-Z][^a-zA-Z]*/g);
                    if (!commands) return;

                    let firstPoint = null;
                    commands.forEach(cmd => {
                        const type = cmd[0];
                        const args = cmd.slice(1).trim().split(/[,\s]+/).map(Number);

                        switch(type) {
                            case 'M':
                                shape.moveTo(args[0], args[1]);
                                firstPoint = [args[0], args[1]];
                                break;
                            case 'L':
                                shape.lineTo(args[0], args[1]);
                                break;
                            case 'C':
                                shape.bezierCurveTo(
                                    args[0], args[1],
                                    args[2], args[3],
                                    args[4], args[5]
                                );
                                break;
                            case 'Z':
                                if (firstPoint) {
                                    shape.lineTo(firstPoint[0], firstPoint[1]);
                                }
                                break;
                        }
                    });

                    const geometry = new THREE.ShapeGeometry(shape);
                    const material = new THREE.MeshBasicMaterial({
                        color: new THREE.Color(color),
                        side: THREE.DoubleSide,
                        transparent: true,
                        opacity: 0.8,
                        depthWrite: false
                    });

                    const mesh = new THREE.Mesh(geometry, material);
                    mesh.position.z = index * 0.1;
                    scene.add(mesh);
                    console.log(`Added mesh ${index}`);
                });
            }, 2000);
        });
    </script>

</body>

</html>